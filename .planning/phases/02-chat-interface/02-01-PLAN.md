---
phase: 02-chat-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/store/chatStore.ts
  - src/lib/storage/conversations.ts
  - src/hooks/useChat.ts
  - src/hooks/useConversations.ts
autonomous: true
requirements:
  - CHAT-01
  - CHAT-02
  - CHAT-03
  - CHAT-08
  - STOR-01
must_haves:
  truths:
    - User can type messages in an auto-resizing input
    - User can send messages with Enter or Send button
    - AI responses stream token-by-token without UI lag
    - User can clear the current conversation
    - Conversations auto-save to IndexedDB after every message
  artifacts:
    - path: src/store/chatStore.ts
      provides: Zustand store for chat state with streaming support
      exports: ["useChatStore", "useMessages", "useIsStreaming"]
    - path: src/lib/storage/conversations.ts
      provides: Conversation CRUD operations for Dexie
      exports: ["saveConversation", "getConversation", "getAllConversations", "deleteConversation", "updateConversationTitle"]
    - path: src/hooks/useChat.ts
      provides: Main chat hook with sendMessage, streaming, clearChat
      exports: ["useChat"]
    - path: src/hooks/useConversations.ts
      provides: Conversation list management hook
      exports: ["useConversations"]
  key_links:
    - from: useChat.ts
      to: chatStore.ts
      via: Zustand subscription
      pattern: "useChatStore"
    - from: chatStore.ts
      to: conversations.ts
      via: Auto-save after message completion
      pattern: "saveConversation"
    - from: chatStore.ts
      to: inferenceManager.generate()
      via: Async generator for streaming
      pattern: "for await...of inferenceManager.generate()"
---

<objective>
Create the core chat state management and storage layer for streaming conversations.

Purpose: Enable users to send messages, receive streaming AI responses, and have conversations persist to IndexedDB.
Output: chatStore, conversation storage utilities, and custom hooks for chat operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-chat-interface/02-CONTEXT.md
@.planning/phases/02-chat-interface/02-RESEARCH.md
@src/types/index.ts
@src/lib/storage/db.ts
@src/lib/ai/inference.ts
@src/store/modelStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversation storage utilities</name>
  <files>src/lib/storage/conversations.ts</files>
  <action>
    Create conversation CRUD operations in src/lib/storage/conversations.ts:

    1. Import db from './db' and types from '@/types/index'
    2. Implement saveConversation(conversation: Conversation): Promise<void>
       - Use db.conversations.put(conversation) for upsert
    3. Implement getConversation(id: string): Promise<Conversation | undefined>
       - Use db.conversations.get(id)
    4. Implement getAllConversations(): Promise<Conversation[]>
       - Use db.conversations.orderBy('updatedAt').reverse().toArray()
    5. Implement deleteConversation(id: string): Promise<void>
       - Use db.conversations.delete(id)
    6. Implement updateConversationTitle(id: string, title: string): Promise<void>
       - Use db.conversations.update(id, { title, updatedAt: Date.now() })
    7. Implement generateConversationTitle(firstUserMessage: string): string
       - Per user decision: use first 20 chars
       - Break at word boundary if possible
       - Add "..." if truncated

    Follow patterns from CLAUDE.md for error handling and TypeScript strict typing.
  </action>
  <verify>
    npm run type-check passes
    grep -E "(saveConversation|getConversation|deleteConversation)" src/lib/storage/conversations.ts
  </verify>
  <done>
    All 6 CRUD functions exist with proper types and error handling
  </done>
</task>

<task type="auto">
  <name>Task 2: Create chatStore with streaming support</name>
  <files>src/store/chatStore.ts</files>
  <action>
    Create Zustand store in src/store/chatStore.ts:

    1. Define ChatState interface:
       - messages: Message[]
       - currentConversationId: string | null
       - isStreaming: boolean
       - streamingContent: string
       - error: string | null
       - metrics: { tokensPerSecond: number; responseTimeMs: number | null }

    2. Define ChatActions interface:
       - sendMessage(content: string): Promise<void>
       - appendToken(token: string): void
       - stopGeneration(): void
       - clearChat(): void
       - loadConversation(conversation: Conversation): void
       - setError(error: string | null): void

    3. Create store with devtools middleware:
       - Import inferenceManager from '@/lib/ai/inference'
       - Import saveConversation from '@/lib/storage/conversations'
       - Import generateConversationTitle from '@/lib/storage/conversations'

    4. Implement sendMessage action:
       - Generate message ID using crypto.randomUUID()
       - Create user message with role 'user', timestamp Date.now()
       - Add to messages array
       - Set isStreaming = true, reset streamingContent
       - Track start time with performance.now()
       - Get current model from modelStore (use useModelStore.getState())
       - Build messages array for inference (map to {role, content})
       - Use for await...of inferenceManager.generate(messages) for streaming
       - On each token: append to streamingContent, update token count
       - On complete: create assistant message, add to messages, set isStreaming = false
       - Calculate metrics: tokensPerSecond = tokenCount / (elapsedMs / 1000)
       - Auto-save conversation to IndexedDB
       - On error: set error state, set isStreaming = false

    5. Implement stopGeneration action:
       - Call inferenceManager.abort()
       - Set isStreaming = false

    6. Implement clearChat action:
       - Reset messages to empty array
       - Generate new conversationId using crypto.randomUUID()
       - Reset error and streaming state

    7. Implement loadConversation action:
       - Set messages from conversation
       - Set currentConversationId
       - Reset streaming state

    8. Export selector hooks: useMessages, useIsStreaming, useStreamingContent, useChatError, useChatMetrics

    Important: Handle streaming state carefully to avoid excessive re-renders. Use functional updates in set().
  </action>
  <verify>
    npm run type-check passes
    grep -E "(sendMessage|stopGeneration|clearChat)" src/store/chatStore.ts
  </verify>
  <done>
    chatStore exists with all actions, streaming support, and auto-save functionality
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useChat and useConversations hooks</name>
  <files>src/hooks/useChat.ts, src/hooks/useConversations.ts</files>
  <action>
    Create custom hooks for chat operations:

    In src/hooks/useChat.ts:
    1. Import hooks from chatStore selectors
    2. Import useCallback from react
    3. Create useChat hook that returns:
       - messages from useMessages
       - isStreaming from useIsStreaming
       - streamingContent from useStreamingContent
       - error from useChatError
       - metrics from useChatMetrics
       - sendMessage wrapped in useCallback
       - stopGeneration wrapped in useCallback
       - clearChat wrapped in useCallback
       - regenerateMessage function that re-sends last user message

    4. Implement regenerateMessage:
       - Find last user message in messages array
       - If found, truncate messages to before that user message
       - Call sendMessage with the user message content

    In src/hooks/useConversations.ts:
    1. Import useState, useEffect, useCallback from react
    2. Import getAllConversations, deleteConversation from storage
    3. Import useChatStore for loadConversation action
    4. Create useConversations hook with state:
       - conversations: Conversation[]
       - isLoading: boolean
       - error: string | null

    5. Load conversations on mount:
       - useEffect to call getAllConversations
       - Sort by updatedAt desc
       - Set conversations state

    6. Return actions:
       - loadConversation: takes id, fetches from storage, calls chatStore.loadConversation
       - deleteConversation: takes id, shows confirmation (for now just delete), refreshes list
       - refreshConversations: reloads list from storage

    Follow CLAUDE.md patterns for hook structure and error handling.
  </action>
  <verify>
    npm run type-check passes
    grep -E "(useChat|useConversations)" src/hooks/*.ts
  </verify>
  <done>
    Both hooks exist with all required functionality and proper TypeScript types
  </done>
</task>

</tasks>

<verification>
- All TypeScript types compile without errors
- chatStore has streaming support with proper state management
- Conversation storage utilities cover all CRUD operations
- Hooks provide clean API for components
- Auto-save triggers after each message completion
</verification>

<success_criteria>
- User can send messages (via hook API)
- AI responses stream token-by-token
- Conversations persist to IndexedDB
- User can clear chat and start new conversation
- All state management follows Zustand patterns from Phase 1
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat-interface/02-01-SUMMARY.md`
</output>
