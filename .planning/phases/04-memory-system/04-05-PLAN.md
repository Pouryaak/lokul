---
phase: 04-memory-system
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/memory/compaction.ts
  - src/lib/ai/webllm-transport.ts
  - src/lib/memory/eviction.ts
  - src/lib/storage/memory.ts
autonomous: true
requirements:
  - MEM-03
  - MEM-04
gap_closure: true
must_haves:
  truths:
    - "Context guard never proceeds to generation with over-limit payload after compaction"
    - "Compaction exposes over-limit status so transport can apply deterministic fallback handling"
    - "Eviction and pruning run via one coordinator on memory write paths with prune-threshold semantics"
  artifacts:
    - path: "src/lib/memory/compaction.ts"
      provides: "Hard post-compaction guard and explicit over-limit reporting"
      exports: ["compactContext"]
    - path: "src/lib/ai/webllm-transport.ts"
      provides: "Transport handling for compaction over-limit conditions before inference call"
      contains: "over-limit fallback handling"
    - path: "src/lib/memory/eviction.ts"
      provides: "Shared memory limit constants and coordinator for prune+evict"
      exports: ["MEMORY_LIMITS", "pruneExpiredFacts", "evictFactsIfNeeded", "runMemoryMaintenance"]
    - path: "src/lib/storage/memory.ts"
      provides: "Write-path wiring to run memory maintenance coordinator"
      exports: ["saveMemoryFact"]
  key_links:
    - from: "src/lib/ai/webllm-transport.ts"
      to: "src/lib/memory/compaction.ts"
      via: "post-compaction over-limit check"
      pattern: "compactContext\("
    - from: "src/lib/storage/memory.ts"
      to: "src/lib/memory/eviction.ts"
      via: "maintenance coordinator on successful writes"
      pattern: "runMemoryMaintenance\("
    - from: "src/lib/memory/eviction.ts"
      to: "db.memory"
      via: "prune then evict sequence"
      pattern: "pruneExpiredFacts.*evictFactsIfNeeded"
---

<objective>
Close the compaction robustness gap by enforcing a hard post-compaction guard, and align eviction behavior with prune-threshold headroom via coordinated maintenance.

Purpose: MEM-03 remains fragile without a guaranteed under-limit fallback, and memory growth control is incomplete without coordinated prune/evict execution.
Output: Compaction over-limit safety path, transport enforcement, and write-path memory maintenance coordinator.
</objective>

<execution_context>
@/Users/poak/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/poak/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-memory-system/04-CONTEXT.md
@.planning/phases/04-memory-system/04-VERIFICATION.md
@.planning/phases/04-memory-system/04-02-SUMMARY.md
@src/lib/memory/compaction.ts
@src/lib/ai/webllm-transport.ts
@src/lib/memory/eviction.ts
@src/lib/storage/memory.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add hard post-compaction guard and explicit over-limit signal</name>
  <files>
    src/lib/memory/compaction.ts
  </files>
  <action>
    Extend compactContext to surface whether payload remains above threshold after Stage 2 and include deterministic fallback data (for example: overLimit boolean and target limits). Add an internal final safety branch that can further trim/truncate non-critical context when still over threshold, while respecting locked priority decisions (project facts preserved ahead of preference/identity). Also clarify module-level compaction snapshot/listener state with a short comment indicating intentional singleton scope.
  </action>
  <verify>
    - npm run type-check
    - Simulated high-token input keeps compactContext output at/under threshold, or marks explicit overLimit for transport handling
    - Existing stage1/stage2 behavior still works for normal cases
  </verify>
  <done>
    - compactContext no longer silently returns over-limit payloads
    - Over-limit status is machine-readable by transport
    - Singleton compaction state intent is documented clearly
  </done>
</task>

<task type="auto">
  <name>Task 2: Enforce over-limit handling in WebLLM transport before generation</name>
  <files>
    src/lib/ai/webllm-transport.ts
  </files>
  <action>
    Update prepareMessagesForInference to consume the new compaction guard output and block unsafe generation payloads. If compaction still reports over-limit, apply explicit fallback (final truncation path or graceful no-memory fallback) before returning messages to inference. Keep graceful degradation behavior when memory loading fails, and add DEV logs that make over-limit/fallback decisions inspectable.
  </action>
  <verify>
    - npm run type-check
    - Long-conversation stress test does not call inference with over-limit context payload
    - Transport still sends normal payloads unchanged when under threshold
  </verify>
  <done>
    - Over-limit compaction condition is handled before generation call
    - Transport no longer relies on one-pass compaction optimism
    - Existing memory-injection happy path remains intact
  </done>
</task>

<task type="auto">
  <name>Task 3: Align eviction semantics and wire maintenance coordinator on writes</name>
  <files>
    src/lib/memory/eviction.ts
    src/lib/storage/memory.ts
  </files>
  <action>
    In eviction.ts, export shared limits constants (hard cap, prune threshold, max pinned, expiry windows) for reuse and remove duplicated hardcoded limit values across memory modules. Adjust eviction target semantics to prune toward prune-threshold headroom rather than only trimming to hard cap. Add a coordinator function that runs pruneExpiredFacts then evictFactsIfNeeded in sequence. Wire this coordinator into memory write path(s) in storage/memory.ts after successful saves so maintenance runs automatically as memory grows.
  </action>
  <verify>
    - npm run type-check
    - Writing many facts triggers coordinator and results in count pruned toward configured threshold
    - Pinned facts remain exempt from auto-eviction
  </verify>
  <done>
    - Shared memory limits are exported from one source of truth
    - Eviction target follows prune-threshold headroom semantics
    - Write path runs prune+evict coordinator automatically
  </done>
</task>

</tasks>

<verification>
1. Reproduce heavy context scenario and confirm no over-limit generation call path.
2. Seed memory above thresholds and verify maintenance coordinator prunes/evicts correctly.
3. Confirm pinned facts are never auto-evicted during coordinator runs.
</verification>

<success_criteria>
- MEM-03 gains a hard post-compaction safety guarantee.
- MEM-04 compaction remains automatic at threshold with robust fallback behavior.
- Memory maintenance is coordinated and enforced on writes with shared limit constants.
</success_criteria>

<output>
After completion, create `.planning/phases/04-memory-system/04-05-SUMMARY.md`
</output>
