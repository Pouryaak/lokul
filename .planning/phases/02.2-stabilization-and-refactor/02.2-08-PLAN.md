---
phase: 02.2-stabilization-and-refactor
plan: 08
type: execute
wave: 2
depends_on: ["02.2-07"]
files_modified:
  - src/types/index.ts
  - src/lib/utils/errors.ts
  - src/lib/ai/inference.ts
  - src/lib/ai/model-engine.ts
  - src/lib/ai/webllm-transport.ts
  - src/lib/storage/conversations.ts
  - src/hooks/useAIChat.ts
autonomous: true
gap_closure: true
requirements:
  - TECH-12
  - TECH-13
must_haves:
  truths:
    - "Long-running async operations can be cancelled through a shared AbortSignal contract"
    - "Core AI/storage boundaries return structured Result/AppError outcomes instead of throw-only flows"
    - "Retries are bounded and jittered, and repeated model init failures enter circuit-breaker cooldown"
  artifacts:
    - path: "src/lib/ai/model-engine.ts"
      provides: "Retry policy and circuit-breaker transitions for model initialization"
      contains: "open/half-open/closed or equivalent resilience states"
    - path: "src/lib/ai/inference.ts"
      provides: "Result-oriented inference surface and cancellation classification"
      contains: "abort reason mapping"
    - path: "src/lib/ai/webllm-transport.ts"
      provides: "Hierarchical cancellation propagation to inference + persistence"
      contains: "AbortSignal forwarding with deterministic cleanup"
    - path: "src/hooks/useAIChat.ts"
      provides: "User recovery paths for retryable vs non-retryable failures"
      contains: "Result handling at call sites"
  key_links:
    - from: "src/lib/ai/webllm-transport.ts"
      to: "src/lib/ai/inference.ts"
      via: "request-scoped AbortSignal + cancel reason"
      pattern: "abortSignal|cancelReason"
    - from: "src/lib/ai/model-engine.ts"
      to: "src/lib/utils/errors.ts"
      via: "retryability classification and breaker transitions"
      pattern: "retryable|circuit"
---

<objective>
Close async-cancellation and error-consistency gaps by introducing end-to-end AbortSignal threading, structured Result/AppError contracts, and bounded resilience controls.

Purpose: Prevent partial cancellations, retry storms, and ambiguous failure handling in AI + persistence critical paths.
Output: Cancellable async contracts, typed recovery flows, and industry-grade retry/circuit-breaker safeguards.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.2-stabilization-and-refactor/02.2-CONTEXT.md
@.planning/phases/02.2-stabilization-and-refactor/02.2-VERIFICATION.md
@.planning/phases/02.2-stabilization-and-refactor/02.2-GAPS-INDUSTRY-RESEARCH.md
@.planning/phases/02.2-stabilization-and-refactor/02.2-07-SUMMARY.md

## Gap Context

Verification flagged incomplete cancellation and low Result/AppError adoption in business boundaries. Research requires capped exponential backoff + jitter, retry budgets, and circuit-breaker behavior for repeated init failures.

</context>

<tasks>

<task type="auto">
  <name>Define cancellable async contracts and cancellation reason taxonomy</name>
  <files>src/types/index.ts, src/lib/utils/errors.ts, src/lib/storage/conversations.ts</files>
  <action>
    Introduce common async reliability primitives:

    1. Add shared cancellation reason types (`user_stop`, `route_change`, `model_switch`, `shutdown`) and pass-through options that include `signal` + reason metadata.
    2. Update storage APIs that can race or block to accept AbortSignal and return typed aborted/conflict outcomes.
    3. Centralize retryability classification helpers in `errors.ts` so retry logic can reject non-retryable categories early.

    Keep APIs backward-compatible through overloaded wrappers where needed.
  </action>
  <verify>npm run type-check</verify>
  <done>Cancellable contracts and typed cancel/retry classifications are available across AI + storage boundaries</done>
</task>

<task type="auto">
  <name>Refactor AI stack to Result/AppError flow with bounded retries and circuit breaker</name>
  <files>src/lib/ai/inference.ts, src/lib/ai/model-engine.ts, src/lib/ai/webllm-transport.ts</files>
  <action>
    Migrate critical AI paths from throw-only handling to structured outcomes:

    1. Return Result/AppError-style outcomes at model init/generation boundaries and map to user-facing recovery actions at transport level.
    2. Implement capped exponential backoff with jitter and bounded retry budget for retryable initialization failures.
    3. Add circuit-breaker state transitions (open/half-open/closed, or equivalent) to prevent init thrash after repeated failures.
    4. Ensure cancellation propagates from route/UI through transport -> inference -> storage, with guaranteed event-listener/controller cleanup.

    Keep logs DEV-gated and structured for local diagnostics only.
  </action>
  <verify>npm run lint && npm run type-check</verify>
  <done>AI paths are cancellable, retries are bounded, and repeated failures trigger controlled breaker behavior</done>
</task>

<task type="auto">
  <name>Apply Result-based recovery handling in chat persistence/generation orchestration</name>
  <files>src/hooks/useAIChat.ts</files>
  <action>
    Update hook-level orchestration to consume structured outcomes:

    1. Replace broad catch-and-swallow behavior with explicit handling for success/retryable/non-retryable/aborted states.
    2. Wire retry, dismiss, and fallback paths to align with phase decision: every error state has a recovery path.
    3. Ensure persistence + generation cleanup runs deterministically on cancellation and model-switch events.

    Keep hook functions under 50 lines by extracting retry/cancel/error helpers.
  </action>
  <verify>npm run test -- src/hooks 2>/dev/null || npm run type-check</verify>
  <done>useAIChat handles Result/AppError outcomes with deterministic recovery and cancellation cleanup</done>
</task>

</tasks>

<verification>
- Trigger stop, route change, and model switch during generation and verify cancellation reason classification
- Force repeated model init failures and confirm breaker cooldown prevents tight retry loops
- Confirm retry logic only retries retryable errors and respects retry budget
- Run `npm run lint` and `npm run type-check`
</verification>

<success_criteria>
1. AbortSignal is threaded through AI + storage operations that can outlive UI intent
2. Core boundaries return structured Result/AppError outcomes rather than uncategorized exceptions
3. Retry behavior is capped, jittered, and non-retryable failures fail fast
4. Circuit-breaker mode prevents repeated model-init thrashing
</success_criteria>

<output>
After completion, create `.planning/phases/02.2-stabilization-and-refactor/02.2-08-SUMMARY.md`
</output>
