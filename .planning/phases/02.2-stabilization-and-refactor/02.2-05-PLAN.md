---
phase: 02.2-stabilization-and-refactor
plan: 05
type: execute
wave: 3
depends_on: ["02.2-02", "02.2-03"]
files_modified:
  - src/routes/ChatRoute.tsx
  - src/hooks/useConversations.ts
  - src/components/chat-layout/AppSidebar.tsx
  - src/components/Chat/AIChatInterface.tsx
  - src/lib/ai/webllm-transport.ts
autonomous: true
requirements:
  - BUG-01
  - BUG-02
  - BUG-03
must_haves:
  truths:
    - Opening /chat doesn't show ghost conversations
    - No "conversation not found" toasts on normal navigation
    - No duplicate conversations in sidebar
    - Stop generation button works
    - No infinite "creating new conversation" loops
  artifacts:
    - path: src/routes/ChatRoute.tsx
      provides: Fixed conversation creation without loops
      pattern: "useRef for tracking creation state"
    - path: src/hooks/useConversations.ts
      provides: Deduplicated conversation list
      pattern: "Map for deduplication"
    - path: src/components/Chat/AIChatInterface.tsx
      provides: Working abort button
      pattern: "stop() from useChat"
  key_links:
    - from: src/components/Chat/AIChatInterface.tsx
      to: "AI SDK UI stop function"
      via: "stop() from useChat"
---

<objective>
Fix the three critical user-reported bugs: Ghost Conversations, Duplicate Sidebar Entries, and non-functional Abort/Stop Generation.

Purpose: These bugs severely impact user experienceâ€”ghost conversations confuse users, duplicates clutter the sidebar, and broken abort wastes resources.
Output: Clean conversation creation, deduplicated sidebar, and working stop generation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.2-stabilization-and-refactor/02.2-CONTEXT.md

## Critical User-Reported Bugs

From CONTEXT.md and STATE.md:

### 1. Ghost Conversations Bug (ChatRoute.tsx, useConversations.ts)
- Opening `/chat` renders 20+ deleted conversations
- Shows "conversation not found" toasts repeatedly
- Gets stuck in "creating new conversation" loop
- Root cause: Stale activeConversationId in chatStore, race condition between deletion and navigation

### 2. Duplicate Conversations in Sidebar (AppSidebar.tsx, useConversations.ts)
- Same conversation appearing multiple times in sidebar
- Root cause: Likely duplicate entries in IndexedDB or rendering issue with keys

### 3. Abort/Stop Generation Not Working (AIChatInterface.tsx)
- Stop button calls console.log("Stop requested")
- Root cause: Abort not wired through to WebLLM

## Current Broken Code

From STABILITY_AUDIT.md Section 1.1:
```typescript
const handleStop = useCallback(() => {
  // TODO: Implement abort in useAIChat/WebLLMTransport
  console.log("Stop requested");
}, []);
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Ghost Conversations loop in ChatRoute</name>
  <files>src/routes/ChatRoute.tsx</files>
  <action>
Fix the infinite loop in ChatRoute.tsx. Current code creates a new conversation on every render if the effect runs multiple times.

Current code:
```typescript
useEffect(() => {
  const createNewConversation = async () => {
    const modelId = currentModel?.id || defaultModelId;
    const conversation = createConversation(modelId);
    navigate(`/chat/${conversation.id}`, { replace: false });
  };

  createNewConversation();
}, [navigate, currentModel]);
```

Problem: If navigate doesn't complete immediately or component re-renders, it creates multiple conversations.

Fixed code:
```typescript
import { useEffect, useRef } from "react";
import { useNavigate } from "react-router-dom";
import { Loader2 } from "lucide-react";
import { createConversation } from "@/lib/storage/conversations";
import { useModelStore } from "@/store/modelStore";

export function ChatRoute() {
  const navigate = useNavigate();
  const currentModel = useModelStore((state) => state.currentModel);
  const defaultModelId = "gemma-2b-it-q4f16_1-MLC";

  // Use ref to prevent multiple creation attempts
  const isCreatingRef = useRef(false);

  useEffect(() => {
    // Prevent double creation (React StrictMode, re-renders, etc.)
    if (isCreatingRef.current) return;
    isCreatingRef.current = true;

    const createNewConversation = async () => {
      try {
        const modelId = currentModel?.id || defaultModelId;
        const conversation = createConversation(modelId);

        // Navigate to the new conversation
        navigate(`/chat/${conversation.id}`, { replace: false });
      } catch (error) {
        console.error("Failed to create conversation:", error);
        // Reset flag on error so user can retry
        isCreatingRef.current = false;
        setTimeout(() => {
          navigate("/", { replace: true });
        }, 2000);
      }
    };

    createNewConversation();
  }, [navigate, currentModel]);

  return (
    <div className="flex h-full flex-col items-center justify-center bg-[#FFF8F0]">
      <Loader2 className="h-8 w-8 animate-spin text-[#FF6B35]" />
      <p className="mt-4 text-gray-600">Creating new conversation...</p>
    </div>
  );
}
```

Key fix: `isCreatingRef` prevents multiple creation attempts.
  </action>
  <verify>grep -q "isCreatingRef" src/routes/ChatRoute.tsx && grep -q "useRef" src/routes/ChatRoute.tsx</verify>
  <done>ChatRoute uses isCreatingRef to prevent duplicate conversation creation</done>
</task>

<task type="auto">
  <name>Task 2: Fix duplicate conversations in sidebar</name>
  <files>src/hooks/useConversations.ts</files>
  <action>
Fix duplicate conversations appearing in sidebar. This can happen if:
1. IndexedDB has duplicates (rare but possible)
2. React renders with same key
3. Race condition in state updates

Add deduplication in useConversations:

```typescript
/**
 * Load all conversations from storage with deduplication
 */
const loadConversations = useCallback(async (): Promise<void> => {
  setIsLoading(true);
  setError(null);

  try {
    const allConversations = await getAllConversations();

    // Deduplicate by ID (in case of any data issues)
    const seenIds = new Set<string>();
    const deduplicated = allConversations.filter((conv) => {
      if (seenIds.has(conv.id)) {
        if (import.meta.env.DEV) {
          console.warn(`[useConversations] Duplicate conversation ID found: ${conv.id}`);
        }
        return false;
      }
      seenIds.add(conv.id);
      return true;
    });

    setConversations(deduplicated);
  } catch (err) {
    const errorMessage =
      err instanceof Error ? err.message : "Failed to load conversations";
    setError(errorMessage);

    if (import.meta.env.DEV) {
      console.error("[useConversations] Load error:", err);
    }
  } finally {
    setIsLoading(false);
  }
}, []);
```

Also ensure stable keys in AppSidebar when rendering:

```typescript
// In AppSidebar.tsx, ensure conversations map uses stable keys
{conversations.map((conversation) => (
  <ConversationItem
    key={conversation.id} // This should be unique
    conversation={conversation}
    // ...
  />
))}
```

The deduplication in useConversations ensures even if IndexedDB has issues, UI stays clean.
  </action>
  <verify>grep -q "seenIds" src/hooks/useConversations.ts && grep -q "deduplicated" src/hooks/useConversations.ts</verify>
  <done>useConversations deduplicates conversations by ID before setting state</done>
</task>

<task type="auto">
  <name>Task 3: Fix "conversation not found" toasts</name>
  <files>src/hooks/useConversations.ts</files>
  <action>
Remove or fix the "conversation not found" error that's shown repeatedly. The issue is that loadConversation throws an error when conversation isn't found, but this is a normal case (new conversation).

Current problematic code:
```typescript
const loadConversation = useCallback(
  async (id: string): Promise<void> => {
    const conversation = conversations.find((c) => c.id === id);
    if (!conversation) {
      throw new Error(`Conversation not found: ${id}`);
    }
    chatStore.getState().loadConversation(conversation);
  },
  [conversations]
);
```

Since we removed chatStore dependency in Plan 02, this function should be removed entirely. The conversation loading now happens via:
1. URL navigation to /chat/[id]
2. ChatDetailRoute loads from storage directly
3. No need for loadConversation in useConversations

Remove the loadConversation function from useConversations and any code that calls it.

In AppSidebar, instead of calling loadConversation, just navigate:

```typescript
// Old (broken):
await loadConversation(conversation.id);
navigate(`/chat/${conversation.id}`);

// New (fixed):
navigate(`/chat/${conversation.id}`);
```

The navigation triggers ChatDetailRoute which loads the conversation.
  </action>
  <verify>! grep -q "loadConversation" src/hooks/useConversations.ts && echo "PASS: loadConversation removed"</verify>
  <done>loadConversation removed from useConversations, navigation handles loading</done>
</task>

<task type="auto">
  <name>Task 4: Fix AppSidebar to use navigation only</name>
  <files>src/components/chat-layout/AppSidebar.tsx</files>
  <action>
Update AppSidebar to remove loadConversation calls and use navigation only:

Current code likely has:
```typescript
const handleConversationClick = useCallback(async (id: string) => {
  await loadConversation(id); // This throws "not found" errors
  navigate(`/chat/${id}`);
}, [loadConversation, navigate]);
```

Fixed code:
```typescript
const handleConversationClick = useCallback((id: string) => {
  // Just navigate - ChatDetailRoute will load the conversation
  navigate(`/chat/${id}`);
}, [navigate]);
```

Also remove loadConversation from the hook destructuring:

```typescript
// Old:
const { conversations, loadConversation, deleteConversation } = useConversations();

// New:
const { conversations, deleteConversation } = useConversations();
```

This eliminates the "conversation not found" errors because:
1. We don't try to load before navigating
2. ChatDetailRoute handles loading with proper error states
3. No race condition between load and navigation
  </action>
  <verify>grep -q "navigate(\`/chat/\${id}\`)" src/components/chat-layout/AppSidebar.tsx && ! grep -q "loadConversation" src/components/chat-layout/AppSidebar.tsx</verify>
  <done>AppSidebar uses navigation only, no loadConversation calls</done>
</task>

<task type="auto">
  <name>Task 5: Implement working abort/stop generation</name>
  <files>src/components/Chat/AIChatInterface.tsx</files>
  <action>
Fix the non-functional stop generation button. AI SDK UI's useChat hook provides a stop() function.

Current broken code:
```typescript
const handleStop = useCallback(() => {
  // TODO: Implement abort in useAIChat/WebLLMTransport
  console.log("Stop requested");
}, []);
```

Fixed code:
```typescript
export function AIChatInterface({
  conversationId,
  modelId,
  initialMessages,
}: AIChatInterfaceProps) {
  // ... other code ...

  const {
    messages,
    input,
    handleInputChange,
    handleSubmit,
    status,
    error,
    stop, // <-- Get stop from useChat
    reload,
  } = useAIChat({
    conversationId,
    modelId,
    initialMessages: convertToUIMessages(initialMessages),
  });

  // ... other code ...

  const handleStop = useCallback(() => {
    stop();
  }, [stop]);

  // In the JSX, the stop button should call handleStop:
  // <button onClick={handleStop}>Stop</button>
```

The stop() function from useChat will:
1. Abort the current generation via the transport
2. Update status to "ready"
3. Stop the streaming UI

This works because:
- useChat manages the abort signal
- WebLLMTransport receives the abort signal
- inferenceManager.abort() is called
- Generation stops
  </action>
  <verify>grep -q "stop," src/components/Chat/AIChatInterface.tsx && grep -q "stop()" src/components/Chat/AIChatInterface.tsx</verify>
  <done>AIChatInterface uses stop() from useChat for working abort functionality</done>
</task>

<task type="auto">
  <name>Task 6: Ensure transport abort is properly wired</name>
  <files>src/lib/ai/webllm-transport.ts</files>
  <action>
Verify and fix the abort signal propagation in webllm-transport.ts. The abort() method should call inferenceManager.abort().

Current code has:
```typescript
abort(): void {
  inferenceManager.abort();
  if (this.abortController) {
    this.abortController.abort();
    this.abortController = null;
  }
}
```

This looks correct. Ensure it's being called by checking that:
1. AI SDK UI calls transport.abort() when stop() is invoked
2. The stream's cancel() method calls this.abort()

Verify the cancel handler:
```typescript
cancel: () => {
  abortCleanup?.();
  this.abort();
}
```

This should work. If there are issues, ensure inferenceManager.abort() properly calls engine.interruptGenerate().

Add logging in dev mode to verify abort is being called:

```typescript
abort(): void {
  if (import.meta.env.DEV) {
    console.log("[WebLLMTransport] Abort requested");
  }

  inferenceManager.abort();

  if (this.abortController) {
    this.abortController.abort();
    this.abortController = null;
  }
}
```
  </action>
  <verify>grep -q "inferenceManager.abort()" src/lib/ai/webllm-transport.ts</verify>
  <done>Transport abort properly calls inferenceManager.abort()</done>
</task>

</tasks>

<verification>
- Opening /chat creates exactly one conversation
- No "conversation not found" toasts appear
- Sidebar shows no duplicate conversations
- Stop generation button immediately stops AI output
- No infinite loops in conversation creation
</verification>

<success_criteria>
- ChatRoute uses isCreatingRef to prevent duplicate creation
- useConversations deduplicates by ID
- AppSidebar uses navigation only (no loadConversation)
- AIChatInterface.stop() is wired to useChat's stop()
- Transport abort calls inferenceManager.abort()
- All three critical bugs are fixed
</success_criteria>

<output>
After completion, create `.planning/phases/02.2-stabilization-and-refactor/02.2-05-SUMMARY.md`
</output>
