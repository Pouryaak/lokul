---
phase: 02.2-stabilization-and-refactor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/utils/result.ts
  - src/lib/utils/errors.ts
  - src/lib/utils/index.ts
  - src/types/result.ts
autonomous: true
requirements:
  - TECH-01
  - TECH-02
must_haves:
  truths:
    - All async operations return Result<T, E> types
    - Error handling is consistent across the codebase
    - User-facing errors have recovery paths
    - No thrown exceptions in business logic
  artifacts:
    - path: src/types/result.ts
      provides: Result<T, E> type definitions
      exports: ["Result", "Ok", "Err", "ok", "err"]
    - path: src/lib/utils/result.ts
      provides: Result utility functions
      exports: ["map", "mapErr", "unwrap", "unwrapOr", "tryCatch"]
    - path: src/lib/utils/errors.ts
      provides: Application error types
      exports: ["AppError", "ValidationError", "StorageError", "ModelError", "NetworkError"]
  key_links:
    - from: src/lib/utils/result.ts
      to: src/types/result.ts
      via: type imports
      pattern: "import.*from.*types/result"
---

<objective>
Establish industry-level error handling infrastructure with Result<T, E> types, standardized error classes, and utility functions for functional error handling.

Purpose: Replace inconsistent try/catch patterns with predictable, type-safe error handling that forces developers to handle failure cases explicitly.
Output: Core error handling utilities and types used throughout the application.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.2-stabilization-and-refactor/02.2-CONTEXT.md
@.planning/audit/STABILITY_AUDIT.md

## Current Error Handling Issues

From STABILITY_AUDIT.md Section 4.6:
- Multiple error handling patterns exist:
  1. Toast + console: src/components/Chat/AIChatInterface.tsx:86-87
  2. State update: src/store/chatStore.ts:259-264
  3. Throw + catch: src/hooks/useConversations.ts:218-227
  4. Silent fail: src/components/Chat/MessageBubble.tsx:66-69

## Decisions from CONTEXT.md

- **Pattern:** Result<T, E> types or structured error objects, not thrown exceptions
- **User feedback:** Toast for user errors, console for dev details, error boundary for crashes
- **Recovery:** Every error state must have a recovery path (retry, dismiss, fallback)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Result<T, E> type definitions</name>
  <files>src/types/result.ts</files>
  <action>
Create src/types/result.ts with discriminated union Result type:

```typescript
/**
 * Result<T, E> - Discriminated union for functional error handling
 *
 * Represents either success (Ok) or failure (Err).
 * Forces explicit error handling at the type level.
 */

/** Successful result variant */
export type Ok<T> = {
  readonly kind: "ok";
  readonly value: T;
};

/** Failed result variant */
export type Err<E> = {
  readonly kind: "err";
  readonly error: E;
};

/** Result type - either Ok<T> or Err<E> */
export type Result<T, E> = Ok<T> | Err<E>;

/** Type guard for Ok variant */
export function isOk<T, E>(result: Result<T, E>): result is Ok<T> {
  return result.kind === "ok";
}

/** Type guard for Err variant */
export function isErr<T, E>(result: Result<T, E>): result is Err<E> {
  return result.kind === "err";
}

/** Create an Ok result */
export function ok<T>(value: T): Ok<T> {
  return { kind: "ok", value };
}

/** Create an Err result */
export function err<E>(error: E): Err<E> {
  return { kind: "err", error };
}
```

Follow patterns from neverthrow library but keep it lightweight (no dependency).
  </action>
  <verify>grep -q "export type Result" src/types/result.ts && grep -q "export function ok" src/types/result.ts && grep -q "export function err" src/types/result.ts</verify>
  <done>Result types defined with Ok<T>, Err<E>, ok(), err(), isOk(), isErr() exports</done>
</task>

<task type="auto">
  <name>Task 2: Create Result utility functions</name>
  <files>src/lib/utils/result.ts</files>
  <action>
Create src/lib/utils/result.ts with utility functions:

```typescript
/**
 * Result utility functions
 *
 * Functional utilities for working with Result<T, E> types.
 * Inspired by Rust's Result and fp-ts, but simplified for our use case.
 */

import { Result, Ok, Err, ok, err, isOk, isErr } from "@/types/result";

export { isOk, isErr, ok, err };

/**
 * Map a function over a successful result
 * If result is Ok, apply fn to value. If Err, pass through unchanged.
 */
export function map<T, U, E>(result: Result<T, E>, fn: (value: T) => U): Result<U, E> {
  if (isOk(result)) {
    return ok(fn(result.value));
  }
  return result;
}

/**
 * Map a function over an error result
 * If result is Err, apply fn to error. If Ok, pass through unchanged.
 */
export function mapErr<T, E, F>(result: Result<T, E>, fn: (error: E) => F): Result<T, F> {
  if (isErr(result)) {
    return err(fn(result.error));
  }
  return result;
}

/**
 * Unwrap a result, returning the value or throwing
 * Use only when you're certain the result is Ok (e.g., after checking)
 */
export function unwrap<T, E>(result: Result<T, E>): T {
  if (isOk(result)) {
    return result.value;
  }
  throw new Error(`Called unwrap on Err: ${result.error}`);
}

/**
 * Unwrap with a default value
 * Returns value if Ok, defaultValue if Err
 */
export function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {
  if (isOk(result)) {
    return result.value;
  }
  return defaultValue;
}

/**
 * Unwrap with a lazy default (function called only if Err)
 */
export function unwrapOrElse<T, E>(result: Result<T, E>, fn: (error: E) => T): T {
  if (isOk(result)) {
    return result.value;
  }
  return fn(result.error);
}

/**
 * Execute a function that might throw, catching and returning as Result
 */
export async function tryCatch<T, E = Error>(
  fn: () => Promise<T>,
  onError?: (error: unknown) => E
): Promise<Result<T, E>> {
  try {
    const value = await fn();
    return ok(value);
  } catch (error) {
    const mappedError = onError ? onError(error) : (error as E);
    return err(mappedError);
  }
}

/**
 * Synchronous version of tryCatch
 */
export function tryCatchSync<T, E = Error>(
  fn: () => T,
  onError?: (error: unknown) => E
): Result<T, E> {
  try {
    const value = fn();
    return ok(value);
  } catch (error) {
    const mappedError = onError ? onError(error) : (error as E);
    return err(mappedError);
  }
}

/**
 * Match on a result with handlers for both cases
 */
export function match<T, E, U>(
  result: Result<T, E>,
  handlers: {
    ok: (value: T) => U;
    err: (error: E) => U;
  }
): U {
  if (isOk(result)) {
    return handlers.ok(result.value);
  }
  return handlers.err(result.error);
}

/**
 * Flatten a nested Result (Result<Result<T, E>, E> -> Result<T, E>)
 */
export function flatten<T, E>(result: Result<Result<T, E>, E>): Result<T, E> {
  if (isOk(result)) {
    return result.value;
  }
  return result;
}

/**
 * Combine multiple results into one
 * Returns Ok with array of values if all succeed, first Err otherwise
 */
export function combine<T, E>(results: Result<T, E>[]): Result<T[], E> {
  const values: T[] = [];

  for (const result of results) {
    if (isErr(result)) {
      return result;
    }
    values.push(result.value);
  }

  return ok(values);
}
```

Export all from src/lib/utils/index.ts if it exists, or create barrel export.
  </action>
  <verify>grep -q "export function map" src/lib/utils/result.ts && grep -q "export function tryCatch" src/lib/utils/result.ts && grep -q "export function unwrapOr" src/lib/utils/result.ts</verify>
  <done>Result utilities: map, mapErr, unwrap, unwrapOr, tryCatch, match, combine</done>
</task>

<task type="auto">
  <name>Task 3: Create application error types</name>
  <files>src/lib/utils/errors.ts</files>
  <action>
Create src/lib/utils/errors.ts with application-specific error types:

```typescript
/**
 * Application Error Types
 *
 * Structured error types for different failure domains.
 * Each error type includes a code for programmatic handling
 * and a user-friendly message for display.
 */

/** Base error code enum for type-safe error handling */
export type ErrorCode =
  | "VALIDATION_ERROR"
  | "STORAGE_ERROR"
  | "STORAGE_NOT_FOUND"
  | "STORAGE_QUOTA_EXCEEDED"
  | "MODEL_ERROR"
  | "MODEL_NOT_LOADED"
  | "MODEL_DOWNLOAD_FAILED"
  | "NETWORK_ERROR"
  | "UNKNOWN_ERROR"
  | "ABORTED";

/** Base application error interface */
export interface AppError {
  /** Machine-readable error code */
  code: ErrorCode;
  /** Human-readable error message (user-facing) */
  message: string;
  /** Technical details for debugging (dev-facing) */
  details?: string;
  /** Original error that caused this */
  cause?: unknown;
}

/** Create a base error with common fields */
function createError(
  code: ErrorCode,
  message: string,
  details?: string,
  cause?: unknown
): AppError {
  return {
    code,
    message,
    details,
    cause,
  };
}

/** Validation errors (user input, malformed data) */
export function validationError(
  message: string,
  details?: string,
  cause?: unknown
): AppError {
  return createError("VALIDATION_ERROR", message, details, cause);
}

/** Storage errors (IndexedDB operations) */
export function storageError(
  message: string,
  details?: string,
  cause?: unknown
): AppError {
  return createError("STORAGE_ERROR", message, details, cause);
}

/** Storage not found error */
export function notFoundError(
  resource: string,
  id: string,
  cause?: unknown
): AppError {
  return createError(
    "STORAGE_NOT_FOUND",
    `${resource} not found`,
    `${resource} with id '${id}' does not exist`,
    cause
  );
}

/** Storage quota exceeded */
export function quotaExceededError(
  details?: string,
  cause?: unknown
): AppError {
  return createError(
    "STORAGE_QUOTA_EXCEEDED",
    "Storage is full. Please delete some conversations to free up space.",
    details,
    cause
  );
}

/** Model errors (loading, inference) */
export function modelError(
  message: string,
  details?: string,
  cause?: unknown
): AppError {
  return createError("MODEL_ERROR", message, details, cause);
}

/** Model not loaded error */
export function modelNotLoadedError(
  details?: string,
  cause?: unknown
): AppError {
  return createError(
    "MODEL_NOT_LOADED",
    "No AI model is loaded. Please wait for the model to load or refresh the page.",
    details,
    cause
  );
}

/** Model download failed */
export function modelDownloadFailed(
  modelId: string,
  cause?: unknown
): AppError {
  return createError(
    "MODEL_DOWNLOAD_FAILED",
    `Failed to download model. Please check your connection and try again.`,
    `Model '${modelId}' download failed`,
    cause
  );
}

/** Network errors (for future use with external APIs) */
export function networkError(
  message: string,
  details?: string,
  cause?: unknown
): AppError {
  return createError("NETWORK_ERROR", message, details, cause);
}

/** Unknown/unexpected errors */
export function unknownError(
  cause: unknown
): AppError {
  const message = cause instanceof Error ? cause.message : "An unexpected error occurred";
  return createError(
    "UNKNOWN_ERROR",
    "Something went wrong. Please try again.",
    message,
    cause
  );
}

/** Operation was aborted (user cancelled) */
export function abortedError(cause?: unknown): AppError {
  return createError(
    "ABORTED",
    "Operation was cancelled.",
    "User aborted the operation",
    cause
  );
}

/**
 * Convert an unknown error to AppError
 * Use this at catch sites to normalize errors
 */
export function toAppError(error: unknown): AppError {
  if (isAppError(error)) {
    return error;
  }

  if (error instanceof Error) {
    // Check for specific error types by message or name
    if (error.name === "QuotaExceededError" || error.message.includes("quota")) {
      return quotaExceededError(error.message, error);
    }
    if (error.name === "AbortError" || error.message.includes("aborted")) {
      return abortedError(error);
    }
    return unknownError(error);
  }

  return unknownError(error);
}

/** Type guard for AppError */
export function isAppError(error: unknown): error is AppError {
  return (
    typeof error === "object" &&
    error !== null &&
    "code" in error &&
    "message" in error &&
    typeof (error as AppError).code === "string" &&
    typeof (error as AppError).message === "string"
  );
}

/**
 * Get user-friendly message from any error
 */
export function getUserMessage(error: unknown): string {
  if (isAppError(error)) {
    return error.message;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return "An unexpected error occurred";
}

/**
 * Get technical details from any error (for dev console)
 */
export function getTechnicalDetails(error: unknown): string | undefined {
  if (isAppError(error)) {
    return error.details;
  }
  if (error instanceof Error) {
    return error.stack;
  }
  return String(error);
}
```

These error types provide structured, user-friendly errors with recovery hints.
  </action>
  <verify>grep -q "export interface AppError" src/lib/utils/errors.ts && grep -q "export function storageError" src/lib/utils/errors.ts && grep -q "export function toAppError" src/lib/utils/errors.ts</verify>
  <done>Application error types: AppError interface, domain-specific error creators, type guards</done>
</task>

</tasks>

<verification>
- All Result types compile without errors
- Utility functions have proper type inference
- Error types cover all domains (storage, model, validation)
- No runtime dependencies added
</verification>

<success_criteria>
- Result<T, E> types are defined and exported
- Utility functions (map, tryCatch, unwrapOr) are implemented
- AppError types cover storage, model, validation, and network domains
- Type guards work correctly (isOk, isErr, isAppError)
- All files pass TypeScript compilation
</success_criteria>

<output>
After completion, create `.planning/phases/02.2-stabilization-and-refactor/02.2-01-SUMMARY.md`
</output>
