---
phase: 02.2-stabilization-and-refactor
plan: 09
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/chat-layout/AppSidebar.tsx
  - src/components/Chat/AIChatInterface.tsx
  - src/App.tsx
  - src/components/chat-layout/
  - src/components/Chat/
  - eslint.config.js
  - package.json
autonomous: true
gap_closure: true
requirements:
  - TECH-14
must_haves:
  truths:
    - "Core UI components meet the project size limits (components < 200 lines, functions < 50 lines)"
    - "Route orchestration and sidebar/chat UI concerns are split into composable modules with clear ownership"
    - "CI/lint catches size regressions before they re-enter the codebase"
  artifacts:
    - path: "src/components/chat-layout/AppSidebar.tsx"
      provides: "Slim coordinator component with extracted subcomponents/hooks"
      max_lines: 200
    - path: "src/components/Chat/AIChatInterface.tsx"
      provides: "Chat interface split into focused rendering + behavior units"
      max_lines: 200
    - path: "src/App.tsx"
      provides: "App shell with extracted route/model bootstrap helpers"
      max_lines: 200
    - path: "eslint.config.js"
      provides: "Enforced max-lines and max-lines-per-function gates"
      contains: "size-limit lint rules"
  key_links:
    - from: "src/App.tsx"
      to: "src/routes/* and extracted app hooks/components"
      via: "composition-driven route shell"
      pattern: "import"
---

<objective>
Close maintainability gaps by splitting oversized components/functions and enforcing architecture fitness checks so size regressions are blocked automatically.

Purpose: Keep the refactored architecture sustainable and aligned with project constraints.
Output: Modularized UI shell/chat/sidebar structure with line-limit enforcement in lint/CI.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.2-stabilization-and-refactor/02.2-CONTEXT.md
@.planning/phases/02.2-stabilization-and-refactor/02.2-VERIFICATION.md

## Gap Context

Verification identified three key files above the size threshold: `AppSidebar.tsx`, `AIChatInterface.tsx`, and `App.tsx`. CONTEXT.md locks component size at 200 lines (extract by ~150) and function size at 50 lines.

</context>

<tasks>

<task type="auto">
  <name>Refactor AppSidebar into composable units under line limits</name>
  <files>src/components/chat-layout/AppSidebar.tsx, src/components/chat-layout/*</files>
  <action>
    Split sidebar concerns into dedicated components/hooks (header actions, conversation groups, footer/settings, data transforms) so AppSidebar becomes orchestration only.

    Constraints:
    - Final `AppSidebar.tsx` under 200 lines
    - Extracted helper functions under 50 lines
    - Preserve existing UX and behavior (no feature changes)
  </action>
  <verify>npm run lint && npm run type-check</verify>
  <done>AppSidebar is modularized with clear file ownership and enforced size compliance</done>
</task>

<task type="auto">
  <name>Refactor AIChatInterface and App shell to meet architecture limits</name>
  <files>src/components/Chat/AIChatInterface.tsx, src/components/Chat/*, src/App.tsx</files>
  <action>
    Decompose chat and app-shell orchestration:

    1. Extract chat presentation blocks (status/error banner, message viewport, composer actions) and non-trivial handlers into focused units.
    2. Extract app route/model bootstrap logic from `App.tsx` into small hooks/components while preserving route behavior.
    3. Ensure all newly extracted functions adhere to < 50 line guidance.

    Keep imports tidy and avoid introducing circular dependencies.
  </action>
  <verify>npm run lint && npm run type-check</verify>
  <done>AIChatInterface and App.tsx both satisfy size limits without behavioral regressions</done>
</task>

<task type="auto">
  <name>Add architecture fitness checks for size constraints</name>
  <files>eslint.config.js, package.json</files>
  <action>
    Add automated guards so the same regression cannot return:

    1. Configure ESLint `max-lines` for TS/TSX components and `max-lines-per-function` aligned with project policy.
    2. Tune ignores for generated/type declaration files to avoid noisy false positives.
    3. Ensure lint scripts run these checks in local and CI paths.

    The goal is enforcement, not optional convention.
  </action>
  <verify>npm run lint</verify>
  <done>Lint fails when components/functions exceed defined architectural limits</done>
</task>

</tasks>

<verification>
- Confirm line counts: `AppSidebar.tsx`, `AIChatInterface.tsx`, `App.tsx` are each <= 200 lines
- Confirm extracted functions in touched files are <= 50 lines
- Run `npm run lint` and ensure size rules are enforced
- Run `npm run type-check` to verify refactor integrity
</verification>

<success_criteria>
1. Oversized files from verification report are decomposed below project limits
2. Responsibility boundaries between app shell, sidebar, and chat UI are explicit
3. Lint/CI includes enforceable architecture fitness checks for line limits
4. No user-facing regressions are introduced during decomposition
</success_criteria>

<output>
After completion, create `.planning/phases/02.2-stabilization-and-refactor/02.2-09-SUMMARY.md`
</output>
