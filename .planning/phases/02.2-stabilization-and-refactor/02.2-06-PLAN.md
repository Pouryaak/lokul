---
phase: 02.2-stabilization-and-refactor
plan: 06
type: execute
wave: 3
depends_on: ["02.2-01", "02.2-04", "02.2-05"]
files_modified:
  - src/components/ErrorBoundary.tsx
  - src/App.tsx
  - src/components/Chat/AIChatInterface.tsx
  - src/lib/ai/inference.ts
autonomous: true
requirements:
  - TECH-09
  - TECH-10
must_haves:
  truths:
    - Error boundary catches component crashes
    - User sees friendly error message with recovery option
    - No console.log in production code paths
    - All async operations have error handling
    - App recovers gracefully from errors
  artifacts:
    - path: src/components/ErrorBoundary.tsx
      provides: React error boundary component
      exports: ["ErrorBoundary"]
    - path: src/App.tsx
      provides: Error boundary wrapping routes
      pattern: "ErrorBoundary around Routes"
    - path: src/components/Chat/AIChatInterface.tsx
      provides: Dismissible error banner
      pattern: "onDismiss handler"
  key_links:
    - from: src/App.tsx
      to: src/components/ErrorBoundary.tsx
      via: import and JSX wrapping
---

<objective>
Add Error Boundary for crash recovery, implement dismissible error banners, and ensure consistent error handling across the application.

Purpose: Prevent complete app crashes from taking down the UI, give users recovery options, and standardize error UX patterns.
Output: Error boundary protection, dismissible errors, and consistent error handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.2-stabilization-and-refactor/02.2-CONTEXT.md
@.planning/audit/STABILITY_AUDIT.md

## Missing Error Boundary

From STABILITY_AUDIT.md Section 2.4:
- Location: src/App.tsx - No error boundary wrapping routes
- Issue: Any unhandled error in route components will crash the entire application
- Fix: Add React Error Boundary around route content

## Error Banner Issues

From STABILITY_AUDIT.md Section 3.2:
- Location: src/components/Chat/AIChatInterface.tsx:116-126
- Issue: Error banner can only be dismissed by page reload
- Fix: Add dismiss button that clears error state

## Decisions from CONTEXT.md

- **User feedback:** Toast for user errors, console for dev details, error boundary for crashes
- **Recovery:** Every error state must have a recovery path (retry, dismiss, fallback)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorBoundary component</name>
  <files>src/components/ErrorBoundary.tsx</files>
  <action>
Create src/components/ErrorBoundary.tsx with proper React error boundary:

```typescript
/**
 * Error Boundary Component
 *
 * Catches JavaScript errors anywhere in the child component tree,
 * logs those errors, and displays a fallback UI instead of crashing.
 */

import { Component, type ReactNode, type ErrorInfo } from "react";
import { AlertTriangle, RefreshCw, Home } from "lucide-react";

interface Props {
  /** Child components to wrap */
  children: ReactNode;
  /** Optional fallback UI component */
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}

/**
 * React Error Boundary
 *
 * Usage:
 * ```tsx
 * <ErrorBoundary>
 *   <MyComponent />
 * </ErrorBoundary>
 * ```
 */
export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error: Error): State {
    // Update state so the next render shows the fallback UI
    return { hasError: true, error, errorInfo: null };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // Log error details
    if (import.meta.env.DEV) {
      console.error("[ErrorBoundary] Caught error:", error);
      console.error("[ErrorBoundary] Component stack:", errorInfo.componentStack);
    }

    this.setState({ errorInfo });

    // In production, you might send to an error tracking service
    // logErrorToService(error, errorInfo);
  }

  private handleReload = (): void => {
    window.location.reload();
  };

  private handleGoHome = (): void => {
    window.location.href = "/";
  };

  render(): ReactNode {
    if (this.state.hasError) {
      // Custom fallback UI
      return (
        this.props.fallback || (
          <div className="flex min-h-screen flex-col items-center justify-center bg-[#FFF8F0] p-4">
            <div className="w-full max-w-md rounded-2xl bg-white p-8 shadow-lg">
              <div className="flex flex-col items-center text-center">
                <div className="rounded-full bg-red-100 p-4">
                  <AlertTriangle className="h-8 w-8 text-red-500" />
                </div>

                <h2 className="mt-4 text-xl font-semibold text-gray-900">
                  Something went wrong
                </h2>

                <p className="mt-2 text-gray-600">
                  We apologize for the inconvenience. The application encountered
                  an unexpected error.
                </p>

                {import.meta.env.DEV && this.state.error && (
                  <div className="mt-4 w-full rounded-lg bg-gray-100 p-4 text-left">
                    <p className="text-sm font-mono text-red-600">
                      {this.state.error.message}
                    </p>
                    {this.state.errorInfo && (
                      <pre className="mt-2 max-h-32 overflow-auto text-xs text-gray-600">
                        {this.state.errorInfo.componentStack}
                      </pre>
                    )}
                  </div>
                )}

                <div className="mt-6 flex gap-3">
                  <button
                    onClick={this.handleReload}
                    className="flex items-center gap-2 rounded-xl bg-[#FF6B35] px-4 py-2 text-white hover:bg-[#FF6B35]/90"
                  >
                    <RefreshCw className="h-4 w-4" />
                    Reload Page
                  </button>

                  <button
                    onClick={this.handleGoHome}
                    className="flex items-center gap-2 rounded-xl border border-gray-300 px-4 py-2 text-gray-700 hover:bg-gray-50"
                  >
                    <Home className="h-4 w-4" />
                    Go Home
                  </button>
                </div>
              </div>
            </div>
          </div>
        )
      );
    }

    return this.props.children;
  }
}

/**
 * Higher-order component to wrap a component with error boundary
 */
export function withErrorBoundary<P extends object>(
  Component: React.ComponentType<P>,
  fallback?: ReactNode
): React.ComponentType<P> {
  return function WithErrorBoundary(props: P) {
    return (
      <ErrorBoundary fallback={fallback}>
        <Component {...props} />
      </ErrorBoundary>
    );
  };
}
```

This provides:
- Error catching for any child component
- Fallback UI with reload and go home buttons
- Dev mode shows error details
- HOC for easy wrapping
  </action>
  <verify>grep -q "export class ErrorBoundary" src/components/ErrorBoundary.tsx && grep -q "componentDidCatch" src/components/ErrorBoundary.tsx</verify>
  <done>ErrorBoundary component created with fallback UI and recovery actions</done>
</task>

<task type="auto">
  <name>Task 2: Wrap routes with ErrorBoundary in App.tsx</name>
  <files>src/App.tsx</files>
  <action>
Update src/App.tsx to wrap routes with ErrorBoundary:

```typescript
import { ErrorBoundary } from "./components/ErrorBoundary";

/**
 * AppContent component - Router content with routes
 */
function AppContent() {
  // ... existing code ...

  return (
    <ErrorBoundary>
      <Routes>
        {/* Landing page routes */}
        <Route path="/" element={<RootLayout />}>
          <Route index element={<LandingPage />} />
          <Route path="loading" element={<LoadingPage />} />
        </Route>

        {/* Chat routes */}
        <Route path="chat" element={<ChatLayoutWrapper />}>
          <Route index element={<ChatRoute />} />
          <Route path=":id" element={<ChatDetailRoute />} />
        </Route>

        {/* Catch-all redirect to landing */}
        <Route path="*" element={<LandingPage />} />
      </Routes>
    </ErrorBoundary>
  );
}
```

Alternative: Wrap specific route components that are more likely to have errors:

```typescript
// Wrap individual routes for finer control
<Route
  path="chat"
  element={
    <ErrorBoundary>
      <ChatLayoutWrapper />
    </ErrorBoundary>
  }
>
```

The global wrap is simpler and catches all errors. Use individual wrapping if you want different fallback UIs for different sections.
  </action>
  <verify>grep -q "ErrorBoundary" src/App.tsx && grep -q "import.*ErrorBoundary" src/App.tsx</verify>
  <done>Routes wrapped with ErrorBoundary in App.tsx</done>
</task>

<task type="auto">
  <name>Task 3: Add dismissible error banner to AIChatInterface</name>
  <files>src/components/Chat/AIChatInterface.tsx</files>
  <action>
Update the error banner in AIChatInterface to be dismissible:

Current code (from audit):
```typescript
{error && (
  <div className="bg-red-500 px-4 py-2 text-center text-sm text-white">
    {error.message}
    <button onClick={() => window.location.reload()}>
      Reload
    </button>
  </div>
)}
```

Fixed code with dismiss button:
```typescript
import { X, AlertCircle, RefreshCw } from "lucide-react";

// In the component, add state for dismissed errors
const [dismissedError, setDismissedError] = useState<string | null>(null);

// Reset dismissed error when error changes
useEffect(() => {
  if (error) {
    setDismissedError(null);
  }
}, [error?.message]);

// In the JSX:
{error && dismissedError !== error.message && (
  <div className="relative bg-red-50 border border-red-200 px-4 py-3 rounded-lg mx-4 mt-4">
    <div className="flex items-start gap-3">
      <AlertCircle className="h-5 w-5 text-red-500 mt-0.5 flex-shrink-0" />

      <div className="flex-1 min-w-0">
        <p className="text-sm font-medium text-red-800">
          Error
        </p>
        <p className="text-sm text-red-600 mt-1">
          {error.message}
        </p>

        <div className="flex gap-2 mt-3">
          <button
            onClick={() => window.location.reload()}
            className="flex items-center gap-1.5 text-sm font-medium text-red-700 hover:text-red-800"
          >
            <RefreshCw className="h-3.5 w-3.5" />
            Reload
          </button>
        </div>
      </div>

      <button
        onClick={() => setDismissedError(error.message)}
        className="flex-shrink-0 rounded-lg p-1 text-red-400 hover:bg-red-100 hover:text-red-600"
        aria-label="Dismiss error"
      >
        <X className="h-4 w-4" />
      </button>
    </div>
  </div>
)}
```

Key improvements:
1. Dismiss button (X) that clears the error display
2. Better visual design with icons
3. Keeps reload option
4. Tracks dismissed errors to prevent re-showing
5. Accessible with aria-label
  </action>
  <verify>grep -q "setDismissedError" src/components/Chat/AIChatInterface.tsx && grep -q "onClick.*setDismissedError" src/components/Chat/AIChatInterface.tsx</verify>
  <done>AIChatInterface has dismissible error banner with X button</done>
</task>

<task type="auto">
  <name>Task 4: Clean up console.log statements</name>
  <files>src/lib/ai/inference.ts, src/hooks/useConversations.ts, src/store/settingsStore.ts</files>
  <action>
Review and clean up console.log statements, keeping only DEV-gated logs:

Files to check from audit:
- src/store/chatStore.ts:267 (will be deleted in Plan 02)
- src/store/settingsStore.ts:96,127,153
- src/hooks/useConversations.ts:188,224,255,295
- src/lib/performance/gpu-detection.ts:136

For each console.log found:
1. If it's for debugging only, wrap in `if (import.meta.env.DEV)`
2. If it's an error log, use console.error (already mostly done)
3. If it's not needed, remove it

Example cleanup in settingsStore.ts:
```typescript
// Before:
console.error("[SettingsStore] Failed to save settings:", error);

// After (keep but ensure it's DEV-gated):
if (import.meta.env.DEV) {
  console.error("[SettingsStore] Failed to save settings:", error);
}
```

In inference.ts:
```typescript
// These are already mostly DEV-gated, verify:
if (import.meta.env.DEV) {
  console.error(`[InferenceManager] Failed to initialize model '${modelId}':`, error);
}
```

Use grep to find all console.log/error/warn:
```bash
grep -rn "console\." src/ --include="*.ts" --include="*.tsx" | grep -v "import.meta.env.DEV"
```

Any console statements not wrapped in DEV checks should be reviewed and either:
1. Wrapped in DEV check
2. Removed if not needed
3. Kept if it's for critical error reporting (rare)
  </action>
  <verify>! grep -rn "console\." src/ --include="*.ts" --include="*.tsx" | grep -v "import.meta.env.DEV" | grep -v "console.error.*Error" | wc -l | xargs test 0 -lt</verify>
  <done>All console statements reviewed and wrapped in DEV checks where appropriate</done>
</task>

<task type="auto">
  <name>Task 5: Add error handling to inference manager</name>
  <files>src/lib/ai/inference.ts</files>
  <action>
Ensure inferenceManager has comprehensive error handling:

Current code has some error handling but verify all async operations:

```typescript
/**
 * Initialize the AI engine with a model
 */
async initialize(
  modelId: string,
  onProgress?: (progress: DownloadProgress) => void
): Promise<void> {
  const model = getModelById(modelId);
  if (!model) {
    throw new Error(`Model not found: ${modelId}`);
  }

  // Clean up existing worker if any
  if (this.worker) {
    this.terminate();
  }

  this.progressCallback = onProgress || null;

  try {
    // Create Web Worker for inference
    this.worker = new Worker(
      new URL("../../workers/inference.worker.ts", import.meta.url),
      { type: "module" }
    );

    // Create WebLLM engine with progress callback
    this.engine = await CreateWebWorkerMLCEngine(this.worker, modelId, {
      initProgressCallback: (report: InitProgressReport) => {
        this.handleProgress(report, model);
      },
    });

    this.currentModel = modelId;
  } catch (error) {
    // Log in dev mode
    if (import.meta.env.DEV) {
      console.error(
        `[InferenceManager] Failed to initialize model '${modelId}':`,
        error
      );
    }

    // Clean up on error
    this.terminate();

    // Re-throw with user-friendly message
    if (error instanceof Error) {
      throw new Error(`Failed to load model: ${error.message}`);
    }
    throw new Error("Failed to load model: Unknown error");
  }
}

/**
 * Generate streaming response from AI
 */
async *generate(messages: Message[]): AsyncGenerator<string> {
  if (!this.engine) {
    throw new Error("Engine not initialized. Call initialize() first.");
  }

  try {
    const stream = await this.engine.chat.completions.create({
      messages,
      stream: true,
      temperature: 0.7,
      max_tokens: 2000,
    });

    for await (const chunk of stream) {
      const content = chunk.choices[0]?.delta?.content || "";
      if (content) {
        yield content;
      }
    }
  } catch (error) {
    // Handle abort gracefully
    if (error instanceof Error && error.name === "AbortError") {
      return; // Silently stop on abort
    }

    if (import.meta.env.DEV) {
      console.error("[InferenceManager] Generation error:", error);
    }

    throw error;
  }
}
```

Ensure:
1. All errors are caught and re-thrown with context
2. Resources are cleaned up on errors
3. Abort errors are handled gracefully
4. DEV-gated logging only
  </action>
  <verify>grep -q "catch (error)" src/lib/ai/inference.ts && grep -q "this.terminate()" src/lib/ai/inference.ts</verify>
  <done>InferenceManager has comprehensive error handling with cleanup</done>
</task>

</tasks>

<verification>
- ErrorBoundary catches and displays fallback UI for crashes
- Dismiss button clears error banners
- No unguarded console.log statements in production
- All async operations have try/catch
- App recovers gracefully from errors
</verification>

<success_criteria>
- ErrorBoundary component created and exported
- Routes wrapped with ErrorBoundary in App.tsx
- AIChatInterface has dismissible error banner
- All console statements reviewed and DEV-gated
- InferenceManager has error handling with cleanup
- User can recover from errors without page reload
</success_criteria>

<output>
After completion, create `.planning/phases/02.2-stabilization-and-refactor/02.2-06-SUMMARY.md`
</output>
