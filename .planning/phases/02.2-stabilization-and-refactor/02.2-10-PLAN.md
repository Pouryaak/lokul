---
phase: 02.2-stabilization-and-refactor
plan: 10
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useAIChat.ts
  - src/lib/storage/conversations.ts
  - src/lib/ai/inference.ts
  - src/lib/ai/webllm-transport.ts
  - src/components/Chat/AIChatInterface.tsx
autonomous: true
gap_closure: true
requirements:
  - TECH-12
  - TECH-02
must_haves:
  truths:
    - "Persistence read/write operations are cancellable from the same request-scoped AbortSignal used by generation"
    - "Core AI/storage orchestration consumes Result/AppError outcomes without throw-first control flow in primary execution paths"
    - "Users get explicit recovery options (retry or dismiss/fallback) when persistence fails"
  artifacts:
    - path: "src/hooks/useAIChat.ts"
      provides: "Abort-aware persistence orchestration with Result-based error branching"
      contains: "signal threading and retry/dismiss recovery actions"
    - path: "src/lib/storage/conversations.ts"
      provides: "Signal-aware persistence APIs with typed aborted/conflict outcomes"
      exports: ["getConversation", "saveConversationWithVersion"]
    - path: "src/lib/ai/inference.ts"
      provides: "Canonical Result-oriented inference entry points for transport callers"
      contains: "safe initialize/generate boundaries used as primary call path"
    - path: "src/lib/ai/webllm-transport.ts"
      provides: "Request-scoped cancellation and Result handling across generation + persistence"
      contains: "single operation scope wiring for signal + cancelReason"
  key_links:
    - from: "src/hooks/useAIChat.ts"
      to: "src/lib/storage/conversations.ts"
      via: "operation-scoped signal passed into persistence reads/writes"
      pattern: "signal"
    - from: "src/lib/ai/webllm-transport.ts"
      to: "src/lib/ai/inference.ts"
      via: "Result-returning generate/initialize APIs"
      pattern: "generateSafe|initializeSafe"
---

<objective>
Close the remaining reliability gaps by finishing end-to-end cancellation wiring and standardizing Result/AppError handling in the active AI + persistence orchestration path.

Purpose: Eliminate partial cancellation behavior and ambiguous error handling while giving users deterministic recovery actions.
Output: Request-scoped AbortSignal propagation through persistence, Result-first orchestration boundaries, and visible retry/dismiss recovery flows.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.2-stabilization-and-refactor/02.2-CONTEXT.md
@.planning/phases/02.2-stabilization-and-refactor/02.2-VERIFICATION.md
@.planning/phases/02.2-stabilization-and-refactor/02.2-08-SUMMARY.md

## Gap Context

Verification still reports partial TECH-12/TECH-02 completion: persistence calls in `useAIChat` are not signal-threaded, throw-based boundaries remain dominant in primary flows, and debounced persistence failures do not expose clear user recovery actions.

</context>

<tasks>

<task type="auto">
  <name>Thread request-scoped AbortSignal through useAIChat persistence lifecycle</name>
  <files>src/hooks/useAIChat.ts, src/lib/storage/conversations.ts</files>
  <action>
    Complete cancellation wiring for persistence boundaries:

    1. In `useAIChat`, create one operation-scoped controller/signal that is shared across persistence read/write/retry steps for a single chat update.
    2. Pass that signal (plus cancel reason metadata where supported) into `getConversation` and `saveConversationWithVersion` calls.
    3. Ensure route change/model switch/user stop paths abort pending persistence and release listeners/timers deterministically.
    4. Keep cancellation handling typed (aborted vs conflict vs terminal error), not generic catch-all errors.

    Preserve existing data behavior; this task closes wiring gaps, not feature behavior changes.
  </action>
  <verify>npm run type-check</verify>
  <done>Persistence reads/writes are abortable from the same request scope as generation and do not leak pending work after cancellation</done>
</task>

<task type="auto">
  <name>Make Result/AppError the primary orchestration boundary in inference and transport</name>
  <files>src/lib/ai/inference.ts, src/lib/ai/webllm-transport.ts, src/hooks/useAIChat.ts</files>
  <action>
    Normalize operational control flow to Result-first handling:

    1. Use `initializeSafe`/`generateSafe` (or equivalent Result-returning boundaries) as primary call path from transport and hook orchestration.
    2. Restrict throw-based wrappers to compatibility boundaries only; avoid throw-first branching in active orchestration flows.
    3. Map Result errors to stable AppError categories and recovery intent (retryable, user-dismissable, fallback-required).
    4. Keep dev diagnostics DEV-gated while preserving user-safe messaging.

    This aligns with locked phase decisions: structured errors, explicit recovery paths, and no swallowed operational failures.
  </action>
  <verify>npm run lint && npm run type-check</verify>
  <done>Primary AI/persistence orchestration no longer depends on throw-first flow and returns categorized Result/AppError outcomes</done>
</task>

<task type="auto">
  <name>Expose deterministic retry and dismiss recovery actions for persistence failures</name>
  <files>src/hooks/useAIChat.ts, src/components/Chat/AIChatInterface.tsx</files>
  <action>
    Replace log-only persistence failure handling with explicit user recovery:

    1. Extend hook-level error state to include actionable recovery metadata (`canRetry`, `retryAction`, `dismissAction`, fallback message).
    2. Wire retry to rerun the failed persistence operation with bounded attempts and preserved idempotency semantics.
    3. Wire dismiss/fallback so users can continue safely when persistence cannot be recovered immediately.
    4. Update chat UI error rendering to show these actions without introducing new product features.

    Keep implementation modular and maintain existing UX language patterns.
  </action>
  <verify>npm run test -- src/hooks 2>/dev/null || npm run type-check</verify>
  <done>Persistence failures are visible to users with concrete retry/dismiss paths instead of silent logs</done>
</task>

</tasks>

<verification>
- Abort generation and navigate away during debounced persistence; verify pending storage work is cancelled cleanly
- Force persistence failures and confirm UI presents retry/dismiss actions with deterministic behavior
- Confirm transport/hook orchestration consumes Result outcomes in primary flow
- Run `npm run lint` and `npm run type-check`
</verification>

<success_criteria>
1. AbortSignal is propagated across generation and persistence within one operation scope
2. Result/AppError handling is canonical in core orchestration boundaries
3. Persistence failures expose explicit retry/dismiss recovery paths
4. TECH-12 and TECH-02 verification gaps are closed with no silent error swallowing
</success_criteria>

<output>
After completion, create `.planning/phases/02.2-stabilization-and-refactor/02.2-10-SUMMARY.md`
</output>
