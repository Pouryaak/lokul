---
phase: 02.1-ai-sdk-ui-migration-with-routing
plan: 06
type: execute
wave: 4
depends_on: ["02.1-03", "02.1-05"]
files_modified:
  - src/routes/ChatDetailRoute.tsx
  - src/hooks/useAIChat.ts
  - src/lib/storage/conversations.ts
autonomous: true
requirements:
  - CHAT-03
  - CHAT-08
must_haves:
  truths:
    - "Conversations persist to IndexedDB after each message"
    - "Messages are loaded from storage when navigating to /chat/[id]"
    - "AI SDK UI state syncs with persistent storage"
    - "Streaming responses are saved after completion"
  artifacts:
    - path: "src/hooks/useAIChat.ts"
      provides: "Updated with persistence integration"
      exports: ["useAIChat"]
    - path: "src/routes/ChatDetailRoute.tsx"
      provides: "Loads conversation from storage into AI SDK UI"
      exports: ["ChatDetailRoute"]
  key_links:
    - from: "useAIChat"
      to: "saveConversation"
      via: "useEffect on messages change"
      pattern: "useEffect(() => { saveConversation(...) }, [messages])"
    - from: "ChatDetailRoute"
      to: "getConversation"
      via: "useEffect on mount"
      pattern: "const conversation = await getConversation(id)"
---

<objective>
Integrate AI SDK UI with persistent storage so conversations are saved to IndexedDB and loaded on route navigation.

Purpose: Without persistence, conversations are lost on page refresh. This integration ensures user data is preserved.
Output: Working persistence layer that syncs AI SDK UI state with IndexedDB.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-ai-sdk-ui-migration-with-routing/02.1-RESEARCH.md

@/Users/poak/Documents/personal-project/Lokul/src/hooks/useAIChat.ts
@/Users/poak/Documents/personal-project/Lokul/src/routes/ChatDetailRoute.tsx
@/Users/poak/Documents/personal-project/Lokul/src/lib/storage/conversations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update useAIChat with persistence</name>
  <files>src/hooks/useAIChat.ts</files>
  <action>
    Update useAIChat hook to persist messages to IndexedDB.

    Current implementation only creates transport. Add persistence:

    ```typescript
    export function useAIChat(options: UseAIChatOptions) {
      const { conversationId, modelId, initialMessages } = options;

      const chat = useChat({
        id: conversationId,
        transport: new WebLLMTransport({ modelId }),
        initialMessages,
      });

      const { messages, setMessages } = chat;

      // Persist messages to IndexedDB when they change
      useEffect(() => {
        if (messages.length === 0) return;

        const persistMessages = async () => {
          try {
            const conversation = await getConversation(conversationId);
            if (!conversation) return;

            // Convert UIMessages to storage format
            const storageMessages = messages.map((msg): StorageMessage => ({
              id: msg.id,
              role: msg.role,
              content: msg.parts
                .filter((p): p is TextPart => p.type === 'text')
                .map((p) => p.text)
                .join(''),
              timestamp: msg.createdAt?.getTime() || Date.now(),
            }));

            conversation.messages = storageMessages;
            conversation.updatedAt = Date.now();

            await saveConversation(conversation);
          } catch (error) {
            console.error('Failed to persist conversation:', error);
          }
        };

        persistMessages();
      }, [messages, conversationId]);

      return chat;
    }
    ```

    Key points:
    1. Import getConversation, saveConversation from storage
    2. Import TextPart type from @ai-sdk/react
    3. Only persist when messages change (not on every render)
    4. Handle errors gracefully (don't break chat if save fails)
    5. Update conversation.updatedAt timestamp

    Add StorageMessage type import from storage module.
  </action>
  <verify>npm run type-check passes</verify>
  <done>useAIChat persists messages to IndexedDB after each change</done>
</task>

<task type="auto">
  <name>Task 2: Update ChatDetailRoute to load conversation</name>
  <files>src/routes/ChatDetailRoute.tsx</files>
  <action>
    Update ChatDetailRoute to load conversation from storage and pass to AIChatInterface.

    ```typescript
    export function ChatDetailRoute() {
      const { id } = useParams<{ id: string }>();
      const navigate = useNavigate();
      const [isLoading, setIsLoading] = useState(true);
      const [conversation, setConversation] = useState<Conversation | null>(null);

      useEffect(() => {
        async function loadConversation() {
          if (!id) return;

          try {
            const conv = await getConversation(id);

            if (!conv) {
              toast.warning('Conversation not found');
              navigate('/chat');
              return;
            }

            setConversation(conv);
          } catch (error) {
            console.error('Failed to load conversation:', error);
            toast.error('Failed to load conversation');
            navigate('/chat');
          } finally {
            setIsLoading(false);
          }
        }

        loadConversation();
      }, [id, navigate]);

      if (isLoading) {
        return (
          <div className="flex h-full items-center justify-center">
            <Loader2 className="h-8 w-8 animate-spin text-[#FF6B35]" />
          </div>
        );
      }

      if (!conversation) {
        return null; // Will redirect
      }

      // Convert storage messages to UIMessages
      const initialMessages: UIMessage[] = conversation.messages.map((msg) => ({
        id: msg.id,
        role: msg.role,
        content: msg.content,
        createdAt: new Date(msg.timestamp),
        parts: [{ type: 'text', text: msg.content }],
      }));

      return (
        <AIChatInterface
          conversationId={id!}
          modelId={conversation.model}
          initialMessages={initialMessages}
        />
      );
    }
    ```

    Key implementation details:
    1. Load conversation from IndexedDB using getConversation(id)
    2. Handle not found case with toast and redirect
    3. Convert storage messages to UIMessage format
    4. Pass initialMessages to AIChatInterface
    5. Show loading spinner while fetching
    6. Pass modelId from conversation to useAIChat

    Import types:
    - Conversation from storage types
    - UIMessage from @ai-sdk/react
    - Loader2 from lucide-react
  </action>
  <verify>npm run type-check passes</verify>
  <done>ChatDetailRoute loads conversation and passes to AIChatInterface</done>
</task>

<task type="auto">
  <name>Task 3: Update AIChatInterface to accept initialMessages</name>
  <files>src/components/chat/AIChatInterface.tsx</files>
  <action>
    Update AIChatInterface props to accept initialMessages and pass to useAIChat.

    ```typescript
    interface AIChatInterfaceProps {
      conversationId: string;
      modelId: string;
      initialMessages?: UIMessage[];
    }

    export function AIChatInterface({
      conversationId,
      modelId,
      initialMessages,
    }: AIChatInterfaceProps) {
      const { messages, sendMessage, status, error, setMessages } = useAIChat({
        conversationId,
        modelId,
        initialMessages,
      });

      // ... rest of component
    }
    ```

    Also update useAIChat options interface to include initialMessages.

    Ensure the component handles both cases:
    1. New conversation (no initialMessages) - shows welcome screen
    2. Existing conversation (with initialMessages) - shows loaded messages

    The welcome screen should only show when messages.length === 0.
  </action>
  <verify>npm run type-check passes</verify>
  <done>AIChatInterface accepts and uses initialMessages prop</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Navigate to /chat - creates new conversation
2. Send a message - persists to IndexedDB
3. Refresh page - conversation loads with messages
4. Navigate to /chat/[id] - loads correct conversation
5. Invalid ID shows toast and redirects
</verification>

<success_criteria>
- Conversations persist to IndexedDB after each message
- Messages load from storage on route navigation
- AI SDK UI state syncs with storage
- Page refresh preserves conversation history
- Invalid conversation IDs handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-ai-sdk-ui-migration-with-routing/02.1-06-SUMMARY.md`
</output>
