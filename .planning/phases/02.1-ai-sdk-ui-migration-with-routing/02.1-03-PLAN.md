---
phase: 02.1-ai-sdk-ui-migration-with-routing
plan: 03
type: execute
wave: 2
depends_on: ["02.1-01", "02.1-02"]
files_modified:
  - src/App.tsx
  - src/routes/ChatRoute.tsx
  - src/routes/ChatDetailRoute.tsx
  - src/routes/RootLayout.tsx
autonomous: true
requirements:
  - CHAT-08
must_haves:
  truths:
    - "Root URL (/) shows landing page without redirect"
    - "/chat creates new empty conversation and redirects to /chat/[id]"
    - "/chat/[id] loads existing conversation from storage"
    - "Non-existent conversation ID redirects to /chat with warning"
    - "Browser history works correctly (back button navigates between chats)"
  artifacts:
    - path: "src/routes/RootLayout.tsx"
      provides: "Root layout for landing page routes"
      exports: ["RootLayout"]
    - path: "src/routes/ChatRoute.tsx"
      provides: "Handler for /chat that creates new conversation"
      exports: ["ChatRoute"]
    - path: "src/routes/ChatDetailRoute.tsx"
      provides: "Handler for /chat/[id] that loads conversation"
      exports: ["ChatDetailRoute"]
    - path: "src/App.tsx"
      provides: "Router configuration with all routes"
      exports: ["App"]
  key_links:
    - from: "ChatRoute"
      to: "createConversation"
      via: "storage API"
      pattern: "createConversation(modelId)"
    - from: "ChatDetailRoute"
      to: "getConversation"
      via: "storage API"
      pattern: "getConversation(id)"
    - from: "App.tsx"
      to: "React Router"
      via: "BrowserRouter and Routes"
      pattern: "<Route path=\"/chat/:id\" />"
---

<objective>
Implement React Router configuration with /chat and /chat/[id] routes. Handle conversation creation and loading with proper redirects.

Purpose: Routing enables URL-based navigation, deep linking to conversations, and browser history support. This transforms the app from state-based to URL-based navigation.
Output: Working router with conversation creation at /chat and conversation display at /chat/[id].
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-ai-sdk-ui-migration-with-routing/02.1-RESEARCH.md

@/Users/poak/Documents/personal-project/Lokul/src/App.tsx
@/Users/poak/Documents/personal-project/Lokul/src/lib/storage/conversations.ts
@/Users/poak/Documents/personal-project/Lokul/src/components/chat-layout/ChatLayout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create route components</name>
  <files>src/routes/RootLayout.tsx, src/routes/ChatRoute.tsx, src/routes/ChatDetailRoute.tsx</files>
  <action>
    Create three route components:

    1. **RootLayout.tsx** - Simple layout for landing page
       - Just renders <Outlet /> for nested routes
       - Used for the root path (/) with landing page as index

    2. **ChatRoute.tsx** - Handles /chat (no ID)
       - On mount, create new conversation using createConversation()
       - Get current model from modelStore
       - Navigate to /chat/{newId} with replace: false (adds to history)
       - Show loading state while creating
       - This satisfies "auto-create new conversation at /chat"

    3. **ChatDetailRoute.tsx** - Handles /chat/:id
       - Get id from useParams()
       - Load conversation using getConversation(id)
       - If not found, redirect to /chat with toast warning
       - If found, render ChatInterface with conversation data
       - Use useAIChat hook with conversationId and loaded messages

    Use React Router's data APIs:
    - useParams() for URL parameters
    - useNavigate() for programmatic navigation
    - useLocation() for state (warning messages)

    For the non-existent conversation redirect:
    ```typescript
    navigate('/chat', { state: { warning: 'Conversation not found' } });
    ```

    Import paths:
    - ChatLayout from '@/components/chat-layout/ChatLayout'
    - useAIChat from '@/hooks/useAIChat'
    - createConversation, getConversation from '@/lib/storage/conversations'
  </action>
  <verify>npm run type-check passes</verify>
  <done>Three route components created with proper TypeScript types</done>
</task>

<task type="auto">
  <name>Task 2: Configure router in App.tsx</name>
  <files>src/App.tsx</files>
  <action>
    Refactor App.tsx to use React Router instead of state-based navigation.

    Current state:
    - Uses appState: 'landing' | 'loading' | 'chat' | 'error'
    - All sections rendered conditionally

    New structure with Router:
    ```tsx
    <BrowserRouter>
      <Routes>
        {/* Landing page routes */}
        <Route path="/" element={<RootLayout />}>
          <Route index element={<LandingPage />} />
        </Route>

        {/* Chat routes */}
        <Route path="chat" element={<ChatLayout />}>
          <Route index element={<ChatRoute />} />
          <Route path=":id" element={<ChatDetailRoute />} />
        </Route>
      </Routes>
    </BrowserRouter>
    ```

    LandingPage component:
    - Extract all landing sections from current App.tsx into a new component
    - Keep handleStart logic but use navigate('/chat') instead of setAppState

    Loading state handling:
    - Model loading should happen before entering chat
    - Keep LoadingScreen for the initial model download
    - After download completes, navigate to /chat

    Preserve existing components:
    - StatusIndicator (always visible)
    - PerformancePanel (toggleable)
    - These should be in ChatLayout or a shared wrapper

    Update handleStart to use navigation:
    ```typescript
    const navigate = useNavigate();
    const handleStart = async () => {
      // ... load model ...
      navigate('/chat');
    };
    ```
  </action>
  <verify>npm run type-check passes</verify>
  <done>App.tsx uses BrowserRouter with /, /chat, and /chat/:id routes</done>
</task>

<task type="auto">
  <name>Task 3: Add toast notifications for warnings</name>
  <files>src/components/ui/sonner.tsx (or toast.tsx)</files>
  <action>
    Add toast notification system for the "conversation not found" warning.

    Install sonner (if not already installed):
    ```bash
    npx shadcn@latest add sonner
    ```

    Or use existing toast component if available.

    In ChatDetailRoute, when redirecting for non-existent conversation:
    ```typescript
    import { toast } from 'sonner';
    // ...
    if (!conversation) {
      toast.warning('Conversation not found');
      navigate('/chat');
      return;
    }
    ```

    Add Toaster component to App.tsx (or ChatLayout) to display toasts:
    ```tsx
    import { Toaster } from '@/components/ui/sonner';
    // ...
    <Toaster />
    ```

    This provides user feedback when they try to access a deleted/non-existent conversation.
  </action>
  <verify>Toast appears when navigating with warning state</verify>
  <done>Toast system installed and integrated for error messages</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compilation passes
2. Routes are properly typed
3. Navigation between routes works
4. /chat creates new conversation
5. /chat/:id loads existing conversation
6. Invalid ID shows toast and redirects
</verification>

<success_criteria>
- BrowserRouter configured in App.tsx
- / route shows landing page
- /chat creates new conversation and redirects
- /chat/:id loads conversation from storage
- Invalid conversation ID shows toast warning
- Browser back button works between conversations
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-ai-sdk-ui-migration-with-routing/02.1-03-SUMMARY.md`
</output>
