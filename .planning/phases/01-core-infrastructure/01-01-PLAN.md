---
phase: 01-core-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/lib/storage/db.ts
  - src/lib/storage/settings.ts
  - src/store/settingsStore.ts
  - src/lib/performance/gpu-detection.ts
autonomous: true
requirements:
  - PERF-01
  - PERF-02
  - STOR-09
must_haves:
  truths:
    - "GPU detection service can check WebGPU availability synchronously"
    - "Settings persist across browser sessions in IndexedDB"
    - "TypeScript types are defined for all domain models"
    - "Zustand store provides reactive settings state"
  artifacts:
    - path: "src/types/index.ts"
      provides: "Domain type definitions (Model, Message, Conversation, Settings)"
      min_lines: 50
    - path: "src/lib/storage/db.ts"
      provides: "Dexie database schema with settings table"
      min_lines: 30
    - path: "src/lib/storage/settings.ts"
      provides: "Settings CRUD operations"
      exports: ["getSettings", "saveSettings", "defaultSettings"]
    - path: "src/store/settingsStore.ts"
      provides: "Reactive settings state with persistence"
      exports: ["useSettingsStore"]
    - path: "src/lib/performance/gpu-detection.ts"
      provides: "WebGPU capability detection"
      exports: ["checkWebGPUSupport", "getGPUInfo"]
  key_links:
    - from: "src/store/settingsStore.ts"
      to: "src/lib/storage/settings.ts"
      via: "load/save operations"
      pattern: "getSettings|saveSettings"
    - from: "src/lib/storage/settings.ts"
      to: "src/lib/storage/db.ts"
      via: "Dexie table operations"
      pattern: "db.settings"
---

<objective>
Establish the foundational infrastructure for Lokul: TypeScript types, IndexedDB storage layer with Dexie, settings persistence, and WebGPU detection capabilities.

Purpose: These building blocks are required by all other features. The storage layer enables offline functionality, GPU detection is required for the first-run experience, and settings persistence satisfies user expectations for preference retention.
Output: Type definitions, working Dexie database, settings store with persistence, and GPU detection utilities.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/research/ARCHITECTURE.md
@.planning/1-CONTEXT.md

Phase 1 Context (locked decisions):
- WebGPU detection: Check `navigator.gpu` availability
- Error message: "Your browser doesn't support WebGPU", "Lokul requires Chrome 120+ or Edge 120+"
- No fallback: No polyfill or degraded mode
- Settings persist across sessions (theme, default model)
</context>

<tasks>

<task type="auto">
<name>Task 1: Create TypeScript type definitions</name>
<files>src/types/index.ts</files>
<action>
Create comprehensive TypeScript type definitions for all domain models:

1. Model type with id, name, description, size, status (downloading | ready | error)
2. Message type with id, role (user | assistant | system), content, timestamp, conversationId
3. Conversation type with id, title, model, messages[], createdAt, updatedAt
4. Settings type with theme (light | dark | system), defaultModel, hasCompletedSetup
5. GPUInfo type with supported (boolean), deviceName (string | null), error (string | null)
6. DownloadProgress type with loaded, total, percentage, estimatedTimeSeconds

Export all types from a single index.ts file. Use strict typing with no `any` types.
</action>
<verify>
grep -q "export interface Model" src/types/index.ts && \
grep -q "export interface Message" src/types/index.ts && \
grep -q "export interface Conversation" src/types/index.ts && \
grep -q "export interface Settings" src/types/index.ts && \
grep -q "export interface GPUInfo" src/types/index.ts
</verify>
<done>All domain types defined with proper interfaces and exported from index.ts</done>
</task>

<task type="auto">
<name>Task 2: Set up Dexie database and settings storage</name>
<files>src/lib/storage/db.ts, src/lib/storage/settings.ts</files>
<action>
Create the IndexedDB layer using Dexie.js:

1. In src/lib/storage/db.ts:
   - Create LokulDatabase class extending Dexie
   - Define tables: settings (id primary key), conversations (id, createdAt, updatedAt), memory (id, key)
   - Export db instance
   - Use schema version 1

2. In src/lib/storage/settings.ts:
   - Define defaultSettings object with theme: "system", defaultModel: "phi-2", hasCompletedSetup: false
   - Create async getSettings(): Promise<Settings> that returns stored settings merged with defaults
   - Create async saveSettings(settings: Partial<Settings>): Promise<void> that upserts to db
   - Handle case where no settings exist yet (return defaults)

Follow patterns from ARCHITECTURE.md Pattern 3. Use proper TypeScript typing with Dexie Table generics.
</action>
<verify>
grep -q "class LokulDatabase extends Dexie" src/lib/storage/db.ts && \
grep -q "settings" src/lib/storage/db.ts && \
grep -q "export const db" src/lib/storage/db.ts && \
grep -q "export const defaultSettings" src/lib/storage/settings.ts && \
grep -q "export async function getSettings" src/lib/storage/settings.ts && \
grep -q "export async function saveSettings" src/lib/storage/settings.ts
</verify>
<done>Dexie database initialized with settings table, CRUD operations working</done>
</task>

<task type="auto">
<name>Task 3: Create settings Zustand store with persistence</name>
<files>src/store/settingsStore.ts</files>
<action>
Create a Zustand store for reactive settings state:

1. Define SettingsState interface with:
   - settings: Settings
   - isLoading: boolean
   - actions: loadSettings, updateSettings, resetSettings

2. Create store using Zustand create():
   - Initialize with defaultSettings and isLoading: true
   - loadSettings: async function that fetches from storage layer and updates state
   - updateSettings: async function that merges partial settings, saves to storage, updates state
   - resetSettings: async function that resets to defaults

3. Use Zustand persist middleware with IndexedDB-based storage (not localStorage):
   - Custom storage adapter that uses src/lib/storage/settings.ts
   - Partialize to only persist the settings object (not isLoading)

Follow patterns from ARCHITECTURE.md Pattern 4. Keep store focused on settings domain only.
</action>
<verify>
grep -q "export const useSettingsStore" src/store/settingsStore.ts && \
grep -q "loadSettings" src/store/settingsStore.ts && \
grep -q "updateSettings" src/store/settingsStore.ts && \
grep -q "persist" src/store/settingsStore.ts
</verify>
<done>Zustand store created with persistence, load/update/reset actions working</done>
</task>

<task type="auto">
<name>Task 4: Implement WebGPU detection utilities</name>
<files>src/lib/performance/gpu-detection.ts</files>
<action>
Create WebGPU detection utilities for first-run experience:

1. Create checkWebGPUSupport(): GPUInfo function that:
   - Checks if navigator.gpu exists
   - If not, returns { supported: false, deviceName: null, error: "WebGPU not available" }
   - If yes, tries to request adapter with powerPreference: "high-performance"
   - Returns { supported: true, deviceName: adapter?.name || "Unknown GPU", error: null }
   - Wrap in try-catch for any unexpected errors

2. Create getGPUInfo(): Promise<GPUInfo> async function for detailed detection

3. Export browser compatibility helper:
   - getRecommendedBrowsers(): returns array of { name, url, icon } for Chrome and Edge
   - isBrowserSupported(): boolean check based on user agent (Chrome 120+, Edge 120+)

Follow error handling patterns from CLAUDE.md. No polyfills or fallbacks per locked decision.
</action>
<verify>
grep -q "export function checkWebGPUSupport" src/lib/performance/gpu-detection.ts && \
grep -q "export function getGPUInfo" src/lib/performance/gpu-detection.ts && \
grep -q "navigator.gpu" src/lib/performance/gpu-detection.ts && \
grep -q "getRecommendedBrowsers" src/lib/performance/gpu-detection.ts
</verify>
<done>GPU detection utilities working, can detect WebGPU support and return browser recommendations</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. TypeScript compiles without errors (npm run type-check or tsc --noEmit)
2. All types are importable from src/types/index.ts
3. Settings can be saved and loaded from IndexedDB
4. Zustand store persists settings across page reloads
5. GPU detection correctly identifies WebGPU availability
</verification>

<success_criteria>
- All domain types defined and exported
- Dexie database schema created with settings table
- Settings CRUD operations working
- Zustand store with persistence functional
- WebGPU detection utilities working
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-01-SUMMARY.md` documenting:
- Types created and their purposes
- Database schema design
- Settings store API
- GPU detection capabilities
</output>
